# Code generated by protox. Don't edit.
# credo:disable-for-this-file
defmodule LivekitProtocolEx.RTPStats do
  @moduledoc false
  if function_exported?(Protox, :check_generator_version, 1) do
    Protox.check_generator_version(1)
  else
    raise "This code was generated with protox 2 but the runtime is using an older version of protox."
  end

  @type t :: %__MODULE__{
          received_report_drift: LivekitProtocolEx.RTPDrift.t() | nil,
          rebased_report_drift: LivekitProtocolEx.RTPDrift.t() | nil,
          ntp_report_drift: LivekitProtocolEx.RTPDrift.t() | nil,
          packet_drift: LivekitProtocolEx.RTPDrift.t() | nil,
          header_bytes_padding: non_neg_integer(),
          header_bytes_duplicate: non_neg_integer(),
          header_bytes: non_neg_integer(),
          nack_repeated: non_neg_integer(),
          nack_acks: non_neg_integer(),
          last_layer_lock_pli: Google.Protobuf.Timestamp.t() | nil,
          layer_lock_plis: non_neg_integer(),
          last_key_frame: Google.Protobuf.Timestamp.t() | nil,
          key_frames: non_neg_integer(),
          rtt_max: non_neg_integer(),
          rtt_current: non_neg_integer(),
          last_fir: Google.Protobuf.Timestamp.t() | nil,
          firs: non_neg_integer(),
          last_pli: Google.Protobuf.Timestamp.t() | nil,
          plis: non_neg_integer(),
          nack_misses: non_neg_integer(),
          nacks: non_neg_integer(),
          gap_histogram: %{integer() => non_neg_integer()},
          jitter_max: float(),
          jitter_current: float(),
          frame_rate: float(),
          frames: non_neg_integer(),
          packets_out_of_order: non_neg_integer(),
          bitrate_padding: float(),
          bytes_padding: non_neg_integer(),
          packet_padding_rate: float(),
          packets_padding: non_neg_integer(),
          bitrate_duplicate: float(),
          bytes_duplicate: non_neg_integer(),
          packet_duplicate_rate: float(),
          packets_duplicate: non_neg_integer(),
          packet_loss_percentage: float(),
          packet_loss_rate: float(),
          packets_lost: non_neg_integer(),
          bitrate: float(),
          bytes: non_neg_integer(),
          packet_rate: float(),
          packets: non_neg_integer(),
          duration: float(),
          end_time: Google.Protobuf.Timestamp.t() | nil,
          start_time: Google.Protobuf.Timestamp.t() | nil,
          __uf__: [{non_neg_integer(), Protox.Types.tag(), binary()}]
        }
  defstruct received_report_drift: nil,
            rebased_report_drift: nil,
            ntp_report_drift: nil,
            packet_drift: nil,
            header_bytes_padding: 0,
            header_bytes_duplicate: 0,
            header_bytes: 0,
            nack_repeated: 0,
            nack_acks: 0,
            last_layer_lock_pli: nil,
            layer_lock_plis: 0,
            last_key_frame: nil,
            key_frames: 0,
            rtt_max: 0,
            rtt_current: 0,
            last_fir: nil,
            firs: 0,
            last_pli: nil,
            plis: 0,
            nack_misses: 0,
            nacks: 0,
            gap_histogram: %{},
            jitter_max: 0.0,
            jitter_current: 0.0,
            frame_rate: 0.0,
            frames: 0,
            packets_out_of_order: 0,
            bitrate_padding: 0.0,
            bytes_padding: 0,
            packet_padding_rate: 0.0,
            packets_padding: 0,
            bitrate_duplicate: 0.0,
            bytes_duplicate: 0,
            packet_duplicate_rate: 0.0,
            packets_duplicate: 0,
            packet_loss_percentage: 0.0,
            packet_loss_rate: 0.0,
            packets_lost: 0,
            bitrate: 0.0,
            bytes: 0,
            packet_rate: 0.0,
            packets: 0,
            duration: 0.0,
            end_time: nil,
            start_time: nil,
            __uf__: []

  (
    (
      @spec encode(t()) :: {:ok, iodata(), non_neg_integer()} | {:error, any()}
      def encode(msg) do
        msg |> encode!() |> Tuple.insert_at(0, :ok)
      rescue
        e in [Protox.EncodingError, Protox.RequiredFieldsError] -> {:error, e}
      end

      @spec encode!(t()) :: {iodata(), non_neg_integer()} | no_return()
      def encode!(msg) do
        {_acc = [], _acc_size = 0}
        |> encode_received_report_drift(msg)
        |> encode_rebased_report_drift(msg)
        |> encode_ntp_report_drift(msg)
        |> encode_packet_drift(msg)
        |> encode_header_bytes_padding(msg)
        |> encode_header_bytes_duplicate(msg)
        |> encode_header_bytes(msg)
        |> encode_nack_repeated(msg)
        |> encode_nack_acks(msg)
        |> encode_last_layer_lock_pli(msg)
        |> encode_layer_lock_plis(msg)
        |> encode_last_key_frame(msg)
        |> encode_key_frames(msg)
        |> encode_rtt_max(msg)
        |> encode_rtt_current(msg)
        |> encode_last_fir(msg)
        |> encode_firs(msg)
        |> encode_last_pli(msg)
        |> encode_plis(msg)
        |> encode_nack_misses(msg)
        |> encode_nacks(msg)
        |> encode_gap_histogram(msg)
        |> encode_jitter_max(msg)
        |> encode_jitter_current(msg)
        |> encode_frame_rate(msg)
        |> encode_frames(msg)
        |> encode_packets_out_of_order(msg)
        |> encode_bitrate_padding(msg)
        |> encode_bytes_padding(msg)
        |> encode_packet_padding_rate(msg)
        |> encode_packets_padding(msg)
        |> encode_bitrate_duplicate(msg)
        |> encode_bytes_duplicate(msg)
        |> encode_packet_duplicate_rate(msg)
        |> encode_packets_duplicate(msg)
        |> encode_packet_loss_percentage(msg)
        |> encode_packet_loss_rate(msg)
        |> encode_packets_lost(msg)
        |> encode_bitrate(msg)
        |> encode_bytes(msg)
        |> encode_packet_rate(msg)
        |> encode_packets(msg)
        |> encode_duration(msg)
        |> encode_end_time(msg)
        |> encode_start_time(msg)
        |> encode_unknown_fields(msg)
      end
    )

    defp encode_received_report_drift({acc, acc_size}, msg) do
      if msg.received_report_drift == nil do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_message(msg.received_report_drift)
        {["\xFA\x02", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:received_report_drift, "invalid field value"),
                __STACKTRACE__
    end

    defp encode_rebased_report_drift({acc, acc_size}, msg) do
      if msg.rebased_report_drift == nil do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_message(msg.rebased_report_drift)
        {["\xF2\x02", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:rebased_report_drift, "invalid field value"),
                __STACKTRACE__
    end

    defp encode_ntp_report_drift({acc, acc_size}, msg) do
      if msg.ntp_report_drift == nil do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_message(msg.ntp_report_drift)
        {["\xEA\x02", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:ntp_report_drift, "invalid field value"), __STACKTRACE__
    end

    defp encode_packet_drift({acc, acc_size}, msg) do
      if msg.packet_drift == nil do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_message(msg.packet_drift)
        {["\xE2\x02", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:packet_drift, "invalid field value"), __STACKTRACE__
    end

    defp encode_header_bytes_padding({acc, acc_size}, msg) do
      if msg.header_bytes_padding == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_uint64(msg.header_bytes_padding)
        {["\xC8\x02", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:header_bytes_padding, "invalid field value"),
                __STACKTRACE__
    end

    defp encode_header_bytes_duplicate({acc, acc_size}, msg) do
      if msg.header_bytes_duplicate == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_uint64(msg.header_bytes_duplicate)
        {["\xC0\x02", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:header_bytes_duplicate, "invalid field value"),
                __STACKTRACE__
    end

    defp encode_header_bytes({acc, acc_size}, msg) do
      if msg.header_bytes == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_uint64(msg.header_bytes)
        {["\xB8\x02", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:header_bytes, "invalid field value"), __STACKTRACE__
    end

    defp encode_nack_repeated({acc, acc_size}, msg) do
      if msg.nack_repeated == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_uint32(msg.nack_repeated)
        {["\xB0\x02", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:nack_repeated, "invalid field value"), __STACKTRACE__
    end

    defp encode_nack_acks({acc, acc_size}, msg) do
      if msg.nack_acks == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_uint32(msg.nack_acks)
        {["\xA8\x02", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:nack_acks, "invalid field value"), __STACKTRACE__
    end

    defp encode_last_layer_lock_pli({acc, acc_size}, msg) do
      if msg.last_layer_lock_pli == nil do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_message(msg.last_layer_lock_pli)
        {["\xA2\x02", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:last_layer_lock_pli, "invalid field value"),
                __STACKTRACE__
    end

    defp encode_layer_lock_plis({acc, acc_size}, msg) do
      if msg.layer_lock_plis == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_uint32(msg.layer_lock_plis)
        {["\x98\x02", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:layer_lock_plis, "invalid field value"), __STACKTRACE__
    end

    defp encode_last_key_frame({acc, acc_size}, msg) do
      if msg.last_key_frame == nil do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_message(msg.last_key_frame)
        {["\x92\x02", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:last_key_frame, "invalid field value"), __STACKTRACE__
    end

    defp encode_key_frames({acc, acc_size}, msg) do
      if msg.key_frames == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_uint32(msg.key_frames)
        {["\x88\x02", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:key_frames, "invalid field value"), __STACKTRACE__
    end

    defp encode_rtt_max({acc, acc_size}, msg) do
      if msg.rtt_max == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_uint32(msg.rtt_max)
        {["\x80\x02", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:rtt_max, "invalid field value"), __STACKTRACE__
    end

    defp encode_rtt_current({acc, acc_size}, msg) do
      if msg.rtt_current == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_uint32(msg.rtt_current)
        {["\xF8\x01", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:rtt_current, "invalid field value"), __STACKTRACE__
    end

    defp encode_last_fir({acc, acc_size}, msg) do
      if msg.last_fir == nil do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_message(msg.last_fir)
        {["\xF2\x01", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:last_fir, "invalid field value"), __STACKTRACE__
    end

    defp encode_firs({acc, acc_size}, msg) do
      if msg.firs == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_uint32(msg.firs)
        {["\xE8\x01", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:firs, "invalid field value"), __STACKTRACE__
    end

    defp encode_last_pli({acc, acc_size}, msg) do
      if msg.last_pli == nil do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_message(msg.last_pli)
        {["\xE2\x01", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:last_pli, "invalid field value"), __STACKTRACE__
    end

    defp encode_plis({acc, acc_size}, msg) do
      if msg.plis == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_uint32(msg.plis)
        {["\xD8\x01", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:plis, "invalid field value"), __STACKTRACE__
    end

    defp encode_nack_misses({acc, acc_size}, msg) do
      if msg.nack_misses == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_uint32(msg.nack_misses)
        {["\xD0\x01", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:nack_misses, "invalid field value"), __STACKTRACE__
    end

    defp encode_nacks({acc, acc_size}, msg) do
      if msg.nacks == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_uint32(msg.nacks)
        {["\xC8\x01", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:nacks, "invalid field value"), __STACKTRACE__
    end

    defp encode_gap_histogram({acc, acc_size}, msg) do
      map = Map.fetch!(msg, :gap_histogram)

      if map_size(map) == 0 do
        {acc, acc_size}
      else
        Enum.reduce(map, {acc, acc_size}, fn {k, v}, {acc, acc_size} ->
          {k_value_bytes, k_value_len} = Protox.Encode.encode_int32(k)
          {v_value_bytes, v_value_len} = Protox.Encode.encode_uint32(v)
          len = 2 + k_value_len + v_value_len
          {len_varint, len_varint_size} = Protox.Varint.encode(len)

          acc = [
            <<"\xC2\x01", len_varint::binary, "\b">>,
            k_value_bytes,
            "\x10",
            v_value_bytes | acc
          ]

          {acc, acc_size + 4 + k_value_len + v_value_len + len_varint_size}
        end)
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:gap_histogram, "invalid field value"), __STACKTRACE__
    end

    defp encode_jitter_max({acc, acc_size}, msg) do
      if msg.jitter_max == 0.0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_double(msg.jitter_max)
        {["\xB9\x01", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:jitter_max, "invalid field value"), __STACKTRACE__
    end

    defp encode_jitter_current({acc, acc_size}, msg) do
      if msg.jitter_current == 0.0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_double(msg.jitter_current)
        {["\xB1\x01", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:jitter_current, "invalid field value"), __STACKTRACE__
    end

    defp encode_frame_rate({acc, acc_size}, msg) do
      if msg.frame_rate == 0.0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_double(msg.frame_rate)
        {["\xA9\x01", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:frame_rate, "invalid field value"), __STACKTRACE__
    end

    defp encode_frames({acc, acc_size}, msg) do
      if msg.frames == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_uint32(msg.frames)
        {["\xA0\x01", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:frames, "invalid field value"), __STACKTRACE__
    end

    defp encode_packets_out_of_order({acc, acc_size}, msg) do
      if msg.packets_out_of_order == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_uint32(msg.packets_out_of_order)
        {["\x98\x01", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:packets_out_of_order, "invalid field value"),
                __STACKTRACE__
    end

    defp encode_bitrate_padding({acc, acc_size}, msg) do
      if msg.bitrate_padding == 0.0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_double(msg.bitrate_padding)
        {["\x91\x01", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:bitrate_padding, "invalid field value"), __STACKTRACE__
    end

    defp encode_bytes_padding({acc, acc_size}, msg) do
      if msg.bytes_padding == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_uint64(msg.bytes_padding)
        {["\x88\x01", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:bytes_padding, "invalid field value"), __STACKTRACE__
    end

    defp encode_packet_padding_rate({acc, acc_size}, msg) do
      if msg.packet_padding_rate == 0.0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_double(msg.packet_padding_rate)
        {["\x81\x01", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:packet_padding_rate, "invalid field value"),
                __STACKTRACE__
    end

    defp encode_packets_padding({acc, acc_size}, msg) do
      if msg.packets_padding == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_uint32(msg.packets_padding)
        {["x", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:packets_padding, "invalid field value"), __STACKTRACE__
    end

    defp encode_bitrate_duplicate({acc, acc_size}, msg) do
      if msg.bitrate_duplicate == 0.0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_double(msg.bitrate_duplicate)
        {["q", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:bitrate_duplicate, "invalid field value"),
                __STACKTRACE__
    end

    defp encode_bytes_duplicate({acc, acc_size}, msg) do
      if msg.bytes_duplicate == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_uint64(msg.bytes_duplicate)
        {["h", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:bytes_duplicate, "invalid field value"), __STACKTRACE__
    end

    defp encode_packet_duplicate_rate({acc, acc_size}, msg) do
      if msg.packet_duplicate_rate == 0.0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_double(msg.packet_duplicate_rate)
        {["a", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:packet_duplicate_rate, "invalid field value"),
                __STACKTRACE__
    end

    defp encode_packets_duplicate({acc, acc_size}, msg) do
      if msg.packets_duplicate == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_uint32(msg.packets_duplicate)
        {["X", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:packets_duplicate, "invalid field value"),
                __STACKTRACE__
    end

    defp encode_packet_loss_percentage({acc, acc_size}, msg) do
      if msg.packet_loss_percentage == 0.0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_float(msg.packet_loss_percentage)
        {["U", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:packet_loss_percentage, "invalid field value"),
                __STACKTRACE__
    end

    defp encode_packet_loss_rate({acc, acc_size}, msg) do
      if msg.packet_loss_rate == 0.0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_double(msg.packet_loss_rate)
        {["I", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:packet_loss_rate, "invalid field value"), __STACKTRACE__
    end

    defp encode_packets_lost({acc, acc_size}, msg) do
      if msg.packets_lost == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_uint32(msg.packets_lost)
        {["@", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:packets_lost, "invalid field value"), __STACKTRACE__
    end

    defp encode_bitrate({acc, acc_size}, msg) do
      if msg.bitrate == 0.0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_double(msg.bitrate)
        {["9", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:bitrate, "invalid field value"), __STACKTRACE__
    end

    defp encode_bytes({acc, acc_size}, msg) do
      if msg.bytes == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_uint64(msg.bytes)
        {["0", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:bytes, "invalid field value"), __STACKTRACE__
    end

    defp encode_packet_rate({acc, acc_size}, msg) do
      if msg.packet_rate == 0.0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_double(msg.packet_rate)
        {[")", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:packet_rate, "invalid field value"), __STACKTRACE__
    end

    defp encode_packets({acc, acc_size}, msg) do
      if msg.packets == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_uint32(msg.packets)
        {[" ", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:packets, "invalid field value"), __STACKTRACE__
    end

    defp encode_duration({acc, acc_size}, msg) do
      if msg.duration == 0.0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_double(msg.duration)
        {["\x19", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:duration, "invalid field value"), __STACKTRACE__
    end

    defp encode_end_time({acc, acc_size}, msg) do
      if msg.end_time == nil do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_message(msg.end_time)
        {["\x12", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:end_time, "invalid field value"), __STACKTRACE__
    end

    defp encode_start_time({acc, acc_size}, msg) do
      if msg.start_time == nil do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_message(msg.start_time)
        {["\n", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:start_time, "invalid field value"), __STACKTRACE__
    end

    defp encode_unknown_fields({acc, acc_size}, msg) do
      Enum.reduce(msg.__uf__, {acc, acc_size}, fn {tag, wire_type, bytes}, {acc, acc_size} ->
        case wire_type do
          0 ->
            {key_bytes, key_size} = Protox.Encode.make_key_bytes(tag, :int32)
            {[acc, <<key_bytes::binary, bytes::binary>>], acc_size + key_size + byte_size(bytes)}

          1 ->
            {key_bytes, key_size} = Protox.Encode.make_key_bytes(tag, :double)
            {[acc, <<key_bytes::binary, bytes::binary>>], acc_size + key_size + byte_size(bytes)}

          2 ->
            {len_bytes, len_size} = bytes |> byte_size() |> Protox.Varint.encode()
            {key_bytes, key_size} = Protox.Encode.make_key_bytes(tag, :packed)

            {[acc, <<key_bytes::binary, len_bytes::binary, bytes::binary>>],
             acc_size + key_size + len_size + byte_size(bytes)}

          5 ->
            {key_bytes, key_size} = Protox.Encode.make_key_bytes(tag, :float)
            {[acc, <<key_bytes::binary, bytes::binary>>], acc_size + key_size + byte_size(bytes)}
        end
      end)
    end
  )

  (
    (
      @spec decode(binary()) :: {:ok, t()} | {:error, any()}
      def decode(bytes) do
        {:ok, decode!(bytes)}
      rescue
        e in [Protox.DecodingError, Protox.IllegalTagError, Protox.RequiredFieldsError] ->
          {:error, e}
      end

      (
        @spec decode!(binary()) :: t() | no_return()
        def decode!(bytes) do
          parse_key_value(bytes, struct(LivekitProtocolEx.RTPStats))
        end
      )
    )

    (
      @spec parse_key_value(binary(), struct()) :: struct()
      defp parse_key_value(<<>>, msg) do
        msg
      end

      defp parse_key_value(bytes, msg) do
        {field, rest} =
          case bytes do
            <<_::5, 3::3, _rest::binary>> ->
              raise Protox.DecodingError.new(bytes, "invalid wire type 3")

            <<_::5, 4::3, _rest::binary>> ->
              raise Protox.DecodingError.new(bytes, "invalid wire type 4")

            <<_::5, 6::3, _rest::binary>> ->
              raise Protox.DecodingError.new(bytes, "invalid wire type 6")

            <<_::5, 7::3, _rest::binary>> ->
              raise Protox.DecodingError.new(bytes, "invalid wire type 7")

            <<0::5, _::3, _rest::binary>> ->
              raise %Protox.IllegalTagError{}

            <<31::5, _wire_type::3, "\x02", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)

              {[
                 received_report_drift:
                   Protox.MergeMessage.merge(
                     msg.received_report_drift,
                     LivekitProtocolEx.RTPDrift.decode!(delimited)
                   )
               ], rest}

            <<30::5, _wire_type::3, "\x02", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)

              {[
                 rebased_report_drift:
                   Protox.MergeMessage.merge(
                     msg.rebased_report_drift,
                     LivekitProtocolEx.RTPDrift.decode!(delimited)
                   )
               ], rest}

            <<29::5, _wire_type::3, "\x02", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)

              {[
                 ntp_report_drift:
                   Protox.MergeMessage.merge(
                     msg.ntp_report_drift,
                     LivekitProtocolEx.RTPDrift.decode!(delimited)
                   )
               ], rest}

            <<28::5, _wire_type::3, "\x02", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)

              {[
                 packet_drift:
                   Protox.MergeMessage.merge(
                     msg.packet_drift,
                     LivekitProtocolEx.RTPDrift.decode!(delimited)
                   )
               ], rest}

            <<25::5, _wire_type::3, "\x02", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_uint64(bytes)
              {[header_bytes_padding: value], rest}

            <<24::5, _wire_type::3, "\x02", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_uint64(bytes)
              {[header_bytes_duplicate: value], rest}

            <<23::5, _wire_type::3, "\x02", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_uint64(bytes)
              {[header_bytes: value], rest}

            <<22::5, _wire_type::3, "\x02", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_uint32(bytes)
              {[nack_repeated: value], rest}

            <<21::5, _wire_type::3, "\x02", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_uint32(bytes)
              {[nack_acks: value], rest}

            <<20::5, _wire_type::3, "\x02", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)

              {[
                 last_layer_lock_pli:
                   Protox.MergeMessage.merge(
                     msg.last_layer_lock_pli,
                     Google.Protobuf.Timestamp.decode!(delimited)
                   )
               ], rest}

            <<19::5, _wire_type::3, "\x02", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_uint32(bytes)
              {[layer_lock_plis: value], rest}

            <<18::5, _wire_type::3, "\x02", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)

              {[
                 last_key_frame:
                   Protox.MergeMessage.merge(
                     msg.last_key_frame,
                     Google.Protobuf.Timestamp.decode!(delimited)
                   )
               ], rest}

            <<17::5, _wire_type::3, "\x02", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_uint32(bytes)
              {[key_frames: value], rest}

            <<16::5, _wire_type::3, "\x02", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_uint32(bytes)
              {[rtt_max: value], rest}

            <<31::5, _wire_type::3, "\x01", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_uint32(bytes)
              {[rtt_current: value], rest}

            <<30::5, _wire_type::3, "\x01", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)

              {[
                 last_fir:
                   Protox.MergeMessage.merge(
                     msg.last_fir,
                     Google.Protobuf.Timestamp.decode!(delimited)
                   )
               ], rest}

            <<29::5, _wire_type::3, "\x01", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_uint32(bytes)
              {[firs: value], rest}

            <<28::5, _wire_type::3, "\x01", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)

              {[
                 last_pli:
                   Protox.MergeMessage.merge(
                     msg.last_pli,
                     Google.Protobuf.Timestamp.decode!(delimited)
                   )
               ], rest}

            <<27::5, _wire_type::3, "\x01", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_uint32(bytes)
              {[plis: value], rest}

            <<26::5, _wire_type::3, "\x01", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_uint32(bytes)
              {[nack_misses: value], rest}

            <<25::5, _wire_type::3, "\x01", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_uint32(bytes)
              {[nacks: value], rest}

            <<24::5, _wire_type::3, "\x01", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)

              {[
                 (
                   {entry_key, entry_value} =
                     (
                       {map_key, map_value} = parse_int32_uint32({:unset, :unset}, delimited)

                       map_key =
                         case map_key do
                           :unset -> Protox.Default.default(:int32)
                           _ -> map_key
                         end

                       map_value =
                         case map_value do
                           :unset -> Protox.Default.default(:uint32)
                           _ -> map_value
                         end

                       {map_key, map_value}
                     )

                   {:gap_histogram, Map.put(msg.gap_histogram, entry_key, entry_value)}
                 )
               ], rest}

            <<23::5, _wire_type::3, "\x01", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_double(bytes)
              {[jitter_max: value], rest}

            <<22::5, _wire_type::3, "\x01", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_double(bytes)
              {[jitter_current: value], rest}

            <<21::5, _wire_type::3, "\x01", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_double(bytes)
              {[frame_rate: value], rest}

            <<20::5, _wire_type::3, "\x01", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_uint32(bytes)
              {[frames: value], rest}

            <<19::5, _wire_type::3, "\x01", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_uint32(bytes)
              {[packets_out_of_order: value], rest}

            <<18::5, _wire_type::3, "\x01", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_double(bytes)
              {[bitrate_padding: value], rest}

            <<17::5, _wire_type::3, "\x01", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_uint64(bytes)
              {[bytes_padding: value], rest}

            <<16::5, _wire_type::3, "\x01", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_double(bytes)
              {[packet_padding_rate: value], rest}

            <<15::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_uint32(bytes)
              {[packets_padding: value], rest}

            <<14::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_double(bytes)
              {[bitrate_duplicate: value], rest}

            <<13::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_uint64(bytes)
              {[bytes_duplicate: value], rest}

            <<12::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_double(bytes)
              {[packet_duplicate_rate: value], rest}

            <<11::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_uint32(bytes)
              {[packets_duplicate: value], rest}

            <<10::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_float(bytes)
              {[packet_loss_percentage: value], rest}

            <<9::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_double(bytes)
              {[packet_loss_rate: value], rest}

            <<8::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_uint32(bytes)
              {[packets_lost: value], rest}

            <<7::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_double(bytes)
              {[bitrate: value], rest}

            <<6::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_uint64(bytes)
              {[bytes: value], rest}

            <<5::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_double(bytes)
              {[packet_rate: value], rest}

            <<4::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_uint32(bytes)
              {[packets: value], rest}

            <<3::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_double(bytes)
              {[duration: value], rest}

            <<2::5, _wire_type::3, bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)

              {[
                 end_time:
                   Protox.MergeMessage.merge(
                     msg.end_time,
                     Google.Protobuf.Timestamp.decode!(delimited)
                   )
               ], rest}

            <<1::5, _wire_type::3, bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)

              {[
                 start_time:
                   Protox.MergeMessage.merge(
                     msg.start_time,
                     Google.Protobuf.Timestamp.decode!(delimited)
                   )
               ], rest}

            <<bytes::binary>> ->
              {tag, wire_type, rest} = Protox.Decode.parse_key(bytes)
              {value, rest} = Protox.Decode.parse_unknown(tag, wire_type, rest)
              {[__uf__: msg.__uf__ ++ [value]], rest}
          end

        msg_updated = struct(msg, field)
        parse_key_value(rest, msg_updated)
      end
    )

    (
      defp parse_int32_uint32(map_entry, <<>>) do
        map_entry
      end

      defp parse_int32_uint32({entry_key, entry_value}, bytes) do
        {map_entry, rest} =
          case Protox.Decode.parse_key(bytes) do
            {1, _, rest} ->
              {res, rest} = Protox.Decode.parse_int32(rest)
              {{res, entry_value}, rest}

            {2, _, rest} ->
              {res, rest} = Protox.Decode.parse_uint32(rest)
              {{entry_key, res}, rest}

            {tag, wire_type, rest} ->
              {_, rest} = Protox.Decode.parse_unknown(tag, wire_type, rest)
              {{entry_key, entry_value}, rest}
          end

        parse_int32_uint32(map_entry, rest)
      end
    )
  )

  (
    @spec unknown_fields(struct()) :: [{non_neg_integer(), Protox.Types.tag(), binary()}]
    def unknown_fields(msg) do
      msg.__uf__
    end

    @spec unknown_fields_name() :: :__uf__
    def unknown_fields_name() do
      :__uf__
    end

    @spec clear_unknown_fields(struct) :: struct
    def clear_unknown_fields(msg) do
      struct!(msg, __uf__: [])
    end
  )

  (
    @spec default(atom()) ::
            {:ok, boolean() | integer() | String.t() | float()}
            | {:error, :no_such_field | :no_default_value}
    def default(:received_report_drift) do
      {:ok, nil}
    end

    def default(:rebased_report_drift) do
      {:ok, nil}
    end

    def default(:ntp_report_drift) do
      {:ok, nil}
    end

    def default(:packet_drift) do
      {:ok, nil}
    end

    def default(:header_bytes_padding) do
      {:ok, 0}
    end

    def default(:header_bytes_duplicate) do
      {:ok, 0}
    end

    def default(:header_bytes) do
      {:ok, 0}
    end

    def default(:nack_repeated) do
      {:ok, 0}
    end

    def default(:nack_acks) do
      {:ok, 0}
    end

    def default(:last_layer_lock_pli) do
      {:ok, nil}
    end

    def default(:layer_lock_plis) do
      {:ok, 0}
    end

    def default(:last_key_frame) do
      {:ok, nil}
    end

    def default(:key_frames) do
      {:ok, 0}
    end

    def default(:rtt_max) do
      {:ok, 0}
    end

    def default(:rtt_current) do
      {:ok, 0}
    end

    def default(:last_fir) do
      {:ok, nil}
    end

    def default(:firs) do
      {:ok, 0}
    end

    def default(:last_pli) do
      {:ok, nil}
    end

    def default(:plis) do
      {:ok, 0}
    end

    def default(:nack_misses) do
      {:ok, 0}
    end

    def default(:nacks) do
      {:ok, 0}
    end

    def default(:gap_histogram) do
      {:error, :no_default_value}
    end

    def default(:jitter_max) do
      {:ok, 0.0}
    end

    def default(:jitter_current) do
      {:ok, 0.0}
    end

    def default(:frame_rate) do
      {:ok, 0.0}
    end

    def default(:frames) do
      {:ok, 0}
    end

    def default(:packets_out_of_order) do
      {:ok, 0}
    end

    def default(:bitrate_padding) do
      {:ok, 0.0}
    end

    def default(:bytes_padding) do
      {:ok, 0}
    end

    def default(:packet_padding_rate) do
      {:ok, 0.0}
    end

    def default(:packets_padding) do
      {:ok, 0}
    end

    def default(:bitrate_duplicate) do
      {:ok, 0.0}
    end

    def default(:bytes_duplicate) do
      {:ok, 0}
    end

    def default(:packet_duplicate_rate) do
      {:ok, 0.0}
    end

    def default(:packets_duplicate) do
      {:ok, 0}
    end

    def default(:packet_loss_percentage) do
      {:ok, 0.0}
    end

    def default(:packet_loss_rate) do
      {:ok, 0.0}
    end

    def default(:packets_lost) do
      {:ok, 0}
    end

    def default(:bitrate) do
      {:ok, 0.0}
    end

    def default(:bytes) do
      {:ok, 0}
    end

    def default(:packet_rate) do
      {:ok, 0.0}
    end

    def default(:packets) do
      {:ok, 0}
    end

    def default(:duration) do
      {:ok, 0.0}
    end

    def default(:end_time) do
      {:ok, nil}
    end

    def default(:start_time) do
      {:ok, nil}
    end

    def default(_) do
      {:error, :no_such_field}
    end
  )

  @spec schema() :: Protox.MessageSchema.t()
  def schema() do
    %{
      __struct__: Protox.MessageSchema,
      fields: %{
        bitrate: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0.0},
          label: :optional,
          name: :bitrate,
          tag: 7,
          type: :double
        },
        bitrate_duplicate: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0.0},
          label: :optional,
          name: :bitrate_duplicate,
          tag: 14,
          type: :double
        },
        bitrate_padding: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0.0},
          label: :optional,
          name: :bitrate_padding,
          tag: 18,
          type: :double
        },
        bytes: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :bytes,
          tag: 6,
          type: :uint64
        },
        bytes_duplicate: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :bytes_duplicate,
          tag: 13,
          type: :uint64
        },
        bytes_padding: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :bytes_padding,
          tag: 17,
          type: :uint64
        },
        duration: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0.0},
          label: :optional,
          name: :duration,
          tag: 3,
          type: :double
        },
        end_time: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: nil},
          label: :optional,
          name: :end_time,
          tag: 2,
          type: {:message, Google.Protobuf.Timestamp}
        },
        firs: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :firs,
          tag: 29,
          type: :uint32
        },
        frame_rate: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0.0},
          label: :optional,
          name: :frame_rate,
          tag: 21,
          type: :double
        },
        frames: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :frames,
          tag: 20,
          type: :uint32
        },
        gap_histogram: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: :map,
          label: nil,
          name: :gap_histogram,
          tag: 24,
          type: {:int32, :uint32}
        },
        header_bytes: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :header_bytes,
          tag: 39,
          type: :uint64
        },
        header_bytes_duplicate: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :header_bytes_duplicate,
          tag: 40,
          type: :uint64
        },
        header_bytes_padding: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :header_bytes_padding,
          tag: 41,
          type: :uint64
        },
        jitter_current: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0.0},
          label: :optional,
          name: :jitter_current,
          tag: 22,
          type: :double
        },
        jitter_max: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0.0},
          label: :optional,
          name: :jitter_max,
          tag: 23,
          type: :double
        },
        key_frames: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :key_frames,
          tag: 33,
          type: :uint32
        },
        last_fir: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: nil},
          label: :optional,
          name: :last_fir,
          tag: 30,
          type: {:message, Google.Protobuf.Timestamp}
        },
        last_key_frame: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: nil},
          label: :optional,
          name: :last_key_frame,
          tag: 34,
          type: {:message, Google.Protobuf.Timestamp}
        },
        last_layer_lock_pli: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: nil},
          label: :optional,
          name: :last_layer_lock_pli,
          tag: 36,
          type: {:message, Google.Protobuf.Timestamp}
        },
        last_pli: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: nil},
          label: :optional,
          name: :last_pli,
          tag: 28,
          type: {:message, Google.Protobuf.Timestamp}
        },
        layer_lock_plis: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :layer_lock_plis,
          tag: 35,
          type: :uint32
        },
        nack_acks: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :nack_acks,
          tag: 37,
          type: :uint32
        },
        nack_misses: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :nack_misses,
          tag: 26,
          type: :uint32
        },
        nack_repeated: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :nack_repeated,
          tag: 38,
          type: :uint32
        },
        nacks: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :nacks,
          tag: 25,
          type: :uint32
        },
        ntp_report_drift: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: nil},
          label: :optional,
          name: :ntp_report_drift,
          tag: 45,
          type: {:message, LivekitProtocolEx.RTPDrift}
        },
        packet_drift: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: nil},
          label: :optional,
          name: :packet_drift,
          tag: 44,
          type: {:message, LivekitProtocolEx.RTPDrift}
        },
        packet_duplicate_rate: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0.0},
          label: :optional,
          name: :packet_duplicate_rate,
          tag: 12,
          type: :double
        },
        packet_loss_percentage: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0.0},
          label: :optional,
          name: :packet_loss_percentage,
          tag: 10,
          type: :float
        },
        packet_loss_rate: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0.0},
          label: :optional,
          name: :packet_loss_rate,
          tag: 9,
          type: :double
        },
        packet_padding_rate: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0.0},
          label: :optional,
          name: :packet_padding_rate,
          tag: 16,
          type: :double
        },
        packet_rate: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0.0},
          label: :optional,
          name: :packet_rate,
          tag: 5,
          type: :double
        },
        packets: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :packets,
          tag: 4,
          type: :uint32
        },
        packets_duplicate: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :packets_duplicate,
          tag: 11,
          type: :uint32
        },
        packets_lost: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :packets_lost,
          tag: 8,
          type: :uint32
        },
        packets_out_of_order: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :packets_out_of_order,
          tag: 19,
          type: :uint32
        },
        packets_padding: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :packets_padding,
          tag: 15,
          type: :uint32
        },
        plis: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :plis,
          tag: 27,
          type: :uint32
        },
        rebased_report_drift: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: nil},
          label: :optional,
          name: :rebased_report_drift,
          tag: 46,
          type: {:message, LivekitProtocolEx.RTPDrift}
        },
        received_report_drift: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: nil},
          label: :optional,
          name: :received_report_drift,
          tag: 47,
          type: {:message, LivekitProtocolEx.RTPDrift}
        },
        rtt_current: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :rtt_current,
          tag: 31,
          type: :uint32
        },
        rtt_max: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :rtt_max,
          tag: 32,
          type: :uint32
        },
        start_time: %{
          __struct__: Protox.Field,
          extender: nil,
          kind: %{__struct__: Protox.Scalar, default_value: nil},
          label: :optional,
          name: :start_time,
          tag: 1,
          type: {:message, Google.Protobuf.Timestamp}
        }
      },
      file_options: %{
        cc_enable_arenas: nil,
        cc_generic_services: nil,
        csharp_namespace: "LiveKit.Proto",
        deprecated: nil,
        features: nil,
        go_package: "github.com/livekit/protocol/livekit",
        java_generate_equals_and_hash: nil,
        java_generic_services: nil,
        java_multiple_files: nil,
        java_outer_classname: nil,
        java_package: nil,
        java_string_check_utf8: nil,
        objc_class_prefix: nil,
        optimize_for: nil,
        php_class_prefix: nil,
        php_metadata_namespace: nil,
        php_namespace: nil,
        py_generic_services: nil,
        ruby_package: "LiveKit::Proto",
        swift_prefix: nil,
        uninterpreted_option: []
      },
      name: LivekitProtocolEx.RTPStats,
      syntax: :proto3
    }
  end
end
